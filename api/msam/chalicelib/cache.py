# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
"""
This file contains helper functions for updating and querying the cache.
"""

import os
import json
from urllib.parse import unquote

import boto3
from boto3.dynamodb.conditions import Key, Attr
from botocore.exceptions import ClientError
from botocore.config import Config

# table names generated by CloudFormation
CONTENT_TABLE_NAME = os.environ["CONTENT_TABLE_NAME"]
CACHED_SERVICES = ["cloudfront-distribution", "mediaconnect-flow", "medialive-channel", "medialive-multiplex"]

# user-agent config
STAMP = os.environ["BUILD_STAMP"]
MSAM_BOTO3_CONFIG = Config(user_agent="aws-media-services-applications-mapper/{stamp}/cache.py".format(stamp=STAMP))


def cached_by_service(service):
    """
    Retrieve items from the cache for the given service name.
    """
    try:
        ddb_table_name = CONTENT_TABLE_NAME
        # ddb_index_name = "service-index"
        ddb_index_name = "ServiceRegionIndex"
        ddb_resource = boto3.resource('dynamodb', config=MSAM_BOTO3_CONFIG)
        ddb_table = ddb_resource.Table(ddb_table_name)
        response = ddb_table.query(IndexName=ddb_index_name, KeyConditionExpression=Key('service').eq(service))
        items = response["Items"]
        # check for paging
        while "LastEvaluatedKey" in response:
            # query again with start key
            response = ddb_table.query(IndexName=ddb_index_name, KeyConditionExpression=Key('service').eq(service), ExclusiveStartKey=response['LastEvaluatedKey'])
            items = items + response["Items"]
        # return when done paging
        return items
    except ClientError as error:
        print(error)
        return {"message": str(error)}


def cached_by_service_region(service, region):
    """
    API entry point to retrieve items from the cache under the service and region name.
    """
    try:
        service = unquote(service)
        region = unquote(region)
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_index_name = "ServiceRegionIndex"
        ddb_resource = boto3.resource('dynamodb', config=MSAM_BOTO3_CONFIG)
        ddb_table = ddb_resource.Table(ddb_table_name)
        response = ddb_table.query(IndexName=ddb_index_name, KeyConditionExpression=Key('service').eq(service) & Key('region').eq(region))
        items = response["Items"]
        while "LastEvaluatedKey" in response:
            response = ddb_table.query(IndexName=ddb_index_name, KeyConditionExpression=Key('service').eq(service) & Key('region').eq(region), ExclusiveStartKey=response['LastEvaluatedKey'])
            items = items + response["Items"]
        return items
    except ClientError as error:
        print(error)
        return {"message": str(error)}


def cached_by_arn(arn):
    """
    API entry point to retrieve an item from the cache under the ARN.
    """
    try:
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb', config=MSAM_BOTO3_CONFIG)
        ddb_table = ddb_resource.Table(ddb_table_name)
        response = ddb_table.query(KeyConditionExpression=Key('arn').eq(str(arn)))
        items = response["Items"]
        while "LastEvaluatedKey" in response:
            response = ddb_table.query(KeyConditionExpression=Key('arn').eq(str(arn)), ExclusiveStartKey=response['LastEvaluatedKey'])
            items = items + response["Items"]
        return items
    except ClientError as error:
        print(error)
        return {"message": str(error)}
    
    
def cached_by_arn_multi(arns):
    """
    API entry point to retrieve an array of items from the cache under the ARNs.
    """
    items = []
    try:
        for arn in arns:
            item = cached_by_arn(arn)
            items.append(item);
        return items
    except ClientError as error:
        print(error)
        return {"message": str(error)}


def cached_by_state(state):
    """
    Return all the content with the specified state.
    """
    items = []
    try:
        req_state = state.upper()
        for CACHED_SERVICE in CACHED_SERVICES:
            cached_items = cached_by_service(CACHED_SERVICE)
            for cached_item in cached_items:
                if "data" in cached_item:
                    item_data = json.loads(cached_item["data"])
                    item_state = item_data["idle_state"]
                    if item_state == req_state: 
                        if req_state == "IDLE":
                            items.append(cached_item)
                        elif req_state == "RUNNING":
                            items.append(cached_item)
    except ClientError as error:
        print(error)
    return items


def cached_by_state_groups():
    """
    Return all the content grouped by state.
    """
    group = {}
    group["idle"] = []
    group["running"] = []
    try:
        for CACHED_SERVICE in CACHED_SERVICES:
            cached_items = cached_by_service(CACHED_SERVICE)
            for cached_item in cached_items:
                if "data" in cached_item:
                    item_data = json.loads(cached_item["data"])
                    item_state = item_data["idle_state"]
                    if item_state:
                        group["idle"].append(cached_item)
                    elif not item_state:
                        group["running"].append(cached_item)
    except ClientError as error:
        print(error)
    return group


def put_cached_data(request):
    """
    API entry point to add items to the cache.
    """
    try:
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb', config=MSAM_BOTO3_CONFIG)
        ddb_table = ddb_resource.Table(ddb_table_name)
        cache_entries = request.json_body
        print(cache_entries)
        # write the channel nodes to the database
        for entry in cache_entries:
            # workaround for dynamodb numeric types
            entry["expires"] = int(entry["expires"])
            entry["updated"] = int(entry["updated"])
            ddb_table.put_item(Item=entry)
        return {"message": "saved"}
    except ClientError as error:
        print(error)
        return {"message": str(error)}


def delete_cached_data(arn):
    """
    API entry point to delete items from the cache.
    """
    try:
        arn = unquote(arn)
        ddb_table_name = CONTENT_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb', config=MSAM_BOTO3_CONFIG)
        ddb_table = ddb_resource.Table(ddb_table_name)
        # cache_entries = request.json_body
        # print(cache_entries)
        # write the channel nodes to the database
        # for entry in cache_entries:
        ddb_table.delete_item(Key={"arn": arn})
        return {"message": "deleted"}
    except ClientError as error:
        print(error)
        return {"message": str(error)}


def regions():
    """
    API entry point to retrieve all regions based on EC2.
    """
    service = boto3.client("ec2", config=MSAM_BOTO3_CONFIG)
    response = service.describe_regions()
    return response["Regions"]
